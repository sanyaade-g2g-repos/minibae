/**************************************************************************** * * dispsampinfo.cpp * * a command line tool using BAE to display sample information * * © Copyright 2000 Beatnik, Inc, All Rights Reserved. * Written by Steve Hales (steve@beatnik.com) * * Legal Notice: *	Beatnik products contain certain trade secrets and confidential and *	proprietary information of Beatnik.  Use, reproduction, disclosure *	and distribution by any means are prohibited, except pursuant to *	a written license from Beatnik. Use of copyright notice is *	precautionary and does not imply publication or disclosure. * * Restricted Rights Legend: *	Use, duplication, or disclosure by the Government is subject to *	restrictions as set forth in subparagraph (c)(1)(ii) of The *	Rights in Technical Data and Computer Software clause in DFARS *	252.227-7013 or subparagraphs (c)(1) and (2) of the Commercial *	Computer Software--Restricted Rights at 48 CFR 52.227-19, as *	applicable. * * Confidential - Internal use only * * History: *	4/24/2000	Created *	10/11/2000	Put a instrument cross reference dump in place. **	10/12/2000	Got rid of the press any key thing, which was Windows specific. **				Now this tool is cross platform. * ****************************************************************************/#include <stdio.h>#include <stdlib.h>// BAE public API's#include "BAE.h"#include "BAEFile.h"// BAE private API's#include "BAEPrivate.h"#include "X_EditorTools.h"#include "X_Formats.h" // prototypeschar const usageString[] =	"USAGE:  dispsampinfo <patches.hsb>\n";// main()// ---------------------------------------------------------------------int main(int argc, char* argv[]){	BAEOutputMixer		*mixer;	BAEResult			err;	BAEFileResource		*file;	BAESampleInfo		info;	long				types, count;	char				*filePath;	BAEResourceType		type;	long				resourceIndex, resourceCount;	BAEResource			data;	BAELongResourceID	id;	char				name[8192];	unsigned long		dataSize;	BAESound			*sound;	unsigned long		totalByteSize;	if (argc != 2)	{		printf(usageString);		return -1;	}		filePath = argv[1];		printf("Beatnik Audio Engine sample display\n");	printf("BAE Copyright 2000, Beatnik, Inc\n\n");	totalByteSize = 0;	mixer = new BAEOutputMixer();	if (mixer)	{		mixer->Open();	}	sound = new BAESound(mixer);	if (sound)	{		file = new BAEFileResource((BAEPathName)filePath, BAE_FILE_READ, &err);		if (file)		{			if (err == BAE_NO_ERROR)			{				err = BAE_UseThisFile((XFILE)file->GetFileReference(), FALSE);				types = file->CountTypes(&err);				if (err == BAE_NO_ERROR)				{					totalByteSize = 0;					printf("Name\tid\trate\tbits\tchannels\tloopstart\tloopend\tframes\tbytes\tinstruments\n");					for (count = 0; count < types; count++)					{						type = file->GetIndexedType(count, &err);						if (err == BAE_NO_ERROR)						{							char typeName[5];							strncpy(typeName, (char *)&type, 4L);							typeName[4] = 0;							switch (type)							{								default://									printf("Ignored type: %s\n", typeName);									break;								case ID_SND:								case ID_CSND:								case ID_ESND:									resourceCount = file->CountResourcesOfType(type, &err);									if (err == BAE_NO_ERROR)									{										for (resourceIndex = 0; resourceIndex < resourceCount; resourceIndex++)										{											data = file->GetIndexedResource(type, &id, resourceIndex, 															name, 8191, &dataSize, &err);											err = sound->LoadBankSample(name);											if (err)											{												strcpy(name, "No name");												err = sound->LoadBankSampleByID(id);											}											if (err == BAE_NO_ERROR)											{												XLongResourceID	usedArray[MAX_INSTRUMENTS * MAX_BANKS];												XLongResourceID	usedCount;												sound->GetInfo(&info);												// get a list of all instruments that use this sample as												// a hard reference.												usedCount = XGetInstrumentsUsingSample(id, 																						usedArray, 																						MAX_INSTRUMENTS * MAX_BANKS);												// display info												printf("%s\t%ld\t%ld\t%d\t%d\t%ld\t%ld\t%ld\t%ld\t", 															name,															id,															UNSIGNED_FIXED_TO_LONG(info.sampledRate), 															info.bitSize, info.channels, 															info.startLoop,															info.endLoop, info.waveFrames,															info.waveFrames * info.channels * (info.bitSize / 8));												// display instruments												if (usedCount)												{													XLongResourceID	ucount;													for (ucount = 0; ucount < usedCount; ucount++)													{														printf("%d\t", usedArray[ucount]);													}													printf("\n");												}												else												{													printf("none\n");												}											}											totalByteSize += info.waveSize;											err = file->DisposeResource(data, dataSize);										}									}									break;							}						}					}					printf("\nTotal sample sizes in bytes: %ld\n", totalByteSize);				}			}			delete file;		}		delete sound;		if (mixer)		{			delete mixer;		}	}	printf("\nAll done.\n");	return 0;}// EOF